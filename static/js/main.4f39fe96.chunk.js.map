{"version":3,"sources":["utils/fibonacci.ts","components/Grid/grid.helper.ts","components/Grid/Cell.tsx","components/Grid/index.tsx","components/App/index.tsx","index.tsx"],"names":["FIBONACCI_NUMBERS","isFibonacciNumber","numberToVerify","isFibonacciSequence","sequence","length","Error","previous","current","restSequence","i","next","populateFibonacciNumbers","COLORS","incrementGridRowColumn","grid","row","column","numberOfRows","numberOfColumns","r","Math","max","c","detectAndResetFibonacciSequence","changedRow","changedColumn","sequenceLength","_grid","commonParams","startIndexRow","endIndexRow","min","startIndexColumn","endIndexColumn","sequenceToVerify","slice","reverse","j","detectAndResetFibonacciSequenceInRows","k","push","detectAndResetFibonacciSequenceInColumns","offset1","offset2","d","detectAndResetFibonacciSequenceInDiagonal1","detectAndResetFibonacciSequenceInDiagonal2","memo","value","id","backgroundColor","useState","reset","setReset","useEffect","setTimeout","data-testid","className","style","Grid","Array","from","getEmptyGrid","setGrid","clickedCell","setClickedCell","timeoutHandle","useRef","onClick","event","stopPropagation","target","clearTimeout","split","map","Number","rowIndex","key","cell","columnIndex","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.4f39fe96.chunk.js","sourcesContent":["const FIBONACCI_NUMBERS: any = {};\n\n// assuming that for this application first 100 fibonacci numbers are enough\nfunction populateFibonacciNumbers(): void {\n  let previous = 1;\n  let current = 1;\n  for (let i = 1; i < 100; i++) {\n    FIBONACCI_NUMBERS[current] = true;\n    [previous, current] = [current, previous + current];\n  }\n}\n\npopulateFibonacciNumbers();\n\nexport function isFibonacciNumber(numberToVerify: number): boolean {\n  return !!FIBONACCI_NUMBERS[numberToVerify];\n}\n\nexport function isFibonacciSequence(sequence: Array<number> = []): boolean {\n  if (sequence.length < 3)\n    throw Error(\"Sequence should have at least 3 numbers\");\n\n  let [previous, current, ...restSequence] = sequence;\n\n  if (!isFibonacciNumber(previous) || !isFibonacciNumber(current)) {\n    return false;\n  }\n\n  for (let i = 0; i < restSequence.length; i++) {\n    const next = restSequence[i];\n    if (next !== previous + current) return false;\n    [previous, current] = [current, next];\n  }\n\n  return true;\n}\n","import {\n  GridShape,\n  GridCell,\n  Grid,\n  ResetFibonacciSequenceParams,\n  DetectAndResetFibonacciSequenceParams,\n} from \"./types\";\nimport { isFibonacciNumber, isFibonacciSequence } from \"../../utils/fibonacci\";\n\nexport const COLORS = {\n  default: \"rgba(0,0,0,0.13)\",\n  onIncrement: \"yellow\",\n  onReset: \"green\",\n};\n\nexport function getEmptyGrid({\n  numberOfRows,\n  numberOfColumns,\n}: GridShape): Array<Array<number>> {\n  return Array.from({ length: numberOfRows }, () =>\n    Array.from({ length: numberOfColumns }, () => -1)\n  );\n}\n\nexport function incrementGridRowColumn({ grid, row, column }: GridCell): Grid {\n  const numberOfRows = grid.length;\n  const numberOfColumns = grid[0].length;\n  if (row > numberOfRows) throw Error(`row should be less than grid row size`);\n  if (column > numberOfColumns)\n    throw Error(`column should be less than grid column size`);\n\n  //increment column\n  for (let r = 0; r < numberOfRows; r++) {\n    grid[r][column] = Math.max(1, grid[r][column] + 1);\n  }\n\n  //increment row\n  for (let c = 0; c < numberOfColumns; c++) {\n    grid[row][c] = Math.max(1, grid[row][c] + 1);\n  }\n\n  //decrement clicked cell value as it gets incremented twice above\n  grid[row][column] -= 1;\n\n  return [...grid];\n}\n\nexport function detectAndResetFibonacciSequence({\n  grid,\n  changedRow,\n  changedColumn,\n  sequenceLength,\n}: ResetFibonacciSequenceParams): Grid {\n  let _grid = [...grid];\n  const numberOfRows = _grid.length;\n  const numberOfColumns = _grid[0].length;\n  const startIndexRow = Math.max(0, changedRow - sequenceLength + 1);\n  const endIndexRow = Math.min(\n    numberOfRows - 1,\n    changedRow + sequenceLength - 1\n  );\n  const startIndexColumn = Math.max(0, changedColumn - sequenceLength + 1);\n  const endIndexColumn = Math.min(\n    numberOfColumns - 1,\n    changedColumn + sequenceLength - 1\n  );\n  const commonParams = {\n    changedRow,\n    changedColumn,\n    sequenceLength,\n    numberOfRows,\n    numberOfColumns,\n    startIndexRow,\n    endIndexRow,\n    startIndexColumn,\n    endIndexColumn,\n  };\n\n  _grid = detectAndResetFibonacciSequenceInRows({\n    grid: _grid,\n    ...commonParams,\n  });\n\n  _grid = detectAndResetFibonacciSequenceInColumns({\n    grid: _grid,\n    ...commonParams,\n  });\n\n  _grid = detectAndResetFibonacciSequenceInDiagonal1({\n    grid: _grid,\n    ...commonParams,\n  });\n\n  _grid = detectAndResetFibonacciSequenceInDiagonal2({\n    grid: _grid,\n    ...commonParams,\n  });\n\n  return _grid;\n}\n\nfunction detectAndResetFibonacciSequenceInRows({\n  grid,\n  changedColumn,\n  sequenceLength,\n  numberOfRows,\n  startIndexColumn,\n  endIndexColumn,\n}: DetectAndResetFibonacciSequenceParams): Grid {\n  for (let r = 0; r < numberOfRows; r++) {\n    if (isFibonacciNumber(grid[r][changedColumn])) {\n      for (\n        let i = startIndexColumn;\n        i <= endIndexColumn - sequenceLength + 1;\n        i++\n      ) {\n        const sequenceToVerify = grid[r].slice(i, i + sequenceLength);\n        if (\n          isFibonacciSequence(sequenceToVerify) ||\n          isFibonacciSequence(sequenceToVerify.reverse())\n        ) {\n          for (let j = i; j < i + sequenceLength; j++) {\n            grid[r][j] = 0;\n          }\n          break;\n        }\n      }\n    }\n  }\n\n  return grid;\n}\n\nfunction detectAndResetFibonacciSequenceInColumns({\n  grid,\n  changedRow,\n  sequenceLength,\n  numberOfColumns,\n  startIndexRow,\n  endIndexRow,\n}: DetectAndResetFibonacciSequenceParams): Grid {\n  for (let c = 0; c < numberOfColumns; c++) {\n    if (isFibonacciNumber(grid[changedRow][c])) {\n      for (let i = startIndexRow; i <= endIndexRow - sequenceLength + 1; i++) {\n        const sequenceToVerify = [];\n        for (let k = i; k < i + sequenceLength; k++) {\n          sequenceToVerify.push(grid[k][c]);\n        }\n\n        if (\n          isFibonacciSequence(sequenceToVerify) ||\n          isFibonacciSequence(sequenceToVerify.reverse())\n        ) {\n          for (let k = i; k < i + sequenceLength; k++) {\n            grid[k][c] = 0;\n          }\n          break;\n        }\n      }\n    }\n  }\n\n  return grid;\n}\n\nfunction detectAndResetFibonacciSequenceInDiagonal1({\n  grid,\n  changedRow,\n  changedColumn,\n  sequenceLength,\n  startIndexRow,\n  endIndexRow,\n  startIndexColumn,\n  endIndexColumn,\n}: DetectAndResetFibonacciSequenceParams): Grid {\n  if (isFibonacciNumber(grid[changedRow][changedColumn])) {\n    const offset1 = Math.max(\n      startIndexColumn - changedColumn,\n      startIndexRow - changedRow\n    );\n    const offset2 = Math.min(\n      endIndexRow - changedRow,\n      endIndexColumn - changedColumn\n    );\n\n    for (let d = offset1; d <= offset2 - sequenceLength + 1; d++) {\n      const sequenceToVerify = [];\n      for (let k = d; k < d + sequenceLength; k++) {\n        sequenceToVerify.push(grid[changedRow + k][changedColumn + k]);\n      }\n\n      if (\n        isFibonacciSequence(sequenceToVerify) ||\n        isFibonacciSequence(sequenceToVerify.reverse())\n      ) {\n        for (let k = d; k < d + sequenceLength; k++) {\n          grid[changedRow + k][changedColumn + k] = 0;\n        }\n        break;\n      }\n    }\n  }\n\n  return grid;\n}\n\nfunction detectAndResetFibonacciSequenceInDiagonal2({\n  grid,\n  changedRow,\n  changedColumn,\n  sequenceLength,\n  startIndexRow,\n  endIndexRow,\n  startIndexColumn,\n  endIndexColumn,\n}: DetectAndResetFibonacciSequenceParams): Grid {\n  if (isFibonacciNumber(grid[changedRow][changedColumn])) {\n    const offset1 = Math.max(\n      startIndexColumn - changedColumn,\n      changedRow - endIndexRow\n    );\n    const offset2 = Math.min(\n      changedRow - startIndexRow,\n      endIndexColumn - changedColumn\n    );\n\n    for (let d = offset1; d <= offset2 - sequenceLength + 1; d++) {\n      const sequenceToVerify = [];\n      for (let k = d; k < d + sequenceLength; k++) {\n        sequenceToVerify.push(grid[changedRow - k][changedColumn + k]);\n      }\n\n      if (\n        isFibonacciSequence(sequenceToVerify) ||\n        isFibonacciSequence(sequenceToVerify.reverse())\n      ) {\n        for (let k = d; k < d + sequenceLength; k++) {\n          grid[changedRow - k][changedColumn + k] = 0;\n        }\n        break;\n      }\n    }\n  }\n\n  return grid;\n}\n","import React, { ReactElement, memo, useEffect, useState } from \"react\";\nimport { CellProps } from \"./types\";\nimport { COLORS } from \"./grid.helper\";\n\nexport default memo(function Cell({\n  value,\n  id,\n  backgroundColor,\n}: CellProps): ReactElement {\n  const [reset, setReset] = useState(false);\n  useEffect(() => {\n    if (value === 0) {\n      setReset(true);\n      setTimeout(() => setReset(false), 500);\n    }\n  }, [value]);\n  return (\n    <div\n      id={id}\n      data-testid={id}\n      className=\"cell\"\n      style={{ backgroundColor: reset ? COLORS.onReset : backgroundColor }}\n    >\n      {value > 0 ? value : \"\"}\n    </div>\n  );\n});\n","import React, { ReactElement, useState, MouseEvent, useRef } from \"react\";\nimport Cell from \"./Cell\";\nimport {\n  getEmptyGrid,\n  incrementGridRowColumn,\n  detectAndResetFibonacciSequence,\n  COLORS,\n} from \"./grid.helper\";\nimport { GridProps } from \"./types\";\n\nimport \"./grid.styles.css\";\n\nexport default function Grid({\n  numberOfRows = 20,\n  numberOfColumns = 20,\n  sequenceLength = 4,\n}: GridProps): ReactElement {\n  const [grid, setGrid] = useState<Array<Array<number>>>(\n    getEmptyGrid({ numberOfRows, numberOfColumns })\n  );\n  const [clickedCell, setClickedCell] = useState({ row: -1, column: -1 });\n  const timeoutHandle = useRef<NodeJS.Timeout>();\n\n  function handleClick(event: MouseEvent<HTMLDivElement>) {\n    event.stopPropagation();\n    const clickedCell = event.target as any;\n    if (clickedCell.id) {\n      if (timeoutHandle.current) clearTimeout(timeoutHandle.current);\n\n      const [row, column] = clickedCell.id.split(\"_\").map(Number);\n\n      setClickedCell({ row, column });\n      setGrid(\n        detectAndResetFibonacciSequence({\n          grid: incrementGridRowColumn({ grid, row, column }),\n          changedColumn: column,\n          changedRow: row,\n          sequenceLength,\n        })\n      );\n\n      timeoutHandle.current = setTimeout(() => {\n        setClickedCell({ row: -1, column: -1 });\n      }, 500);\n    }\n  }\n\n  return (\n    <div onClick={handleClick} className=\"grid\">\n      {grid?.map((row: Array<number>, rowIndex: number) => {\n        return (\n          <div className=\"row\" key={rowIndex}>\n            {row.map((cell: number, columnIndex: number) => (\n              <Cell\n                key={`${rowIndex}_${columnIndex}`}\n                id={`${rowIndex}_${columnIndex}`}\n                value={cell}\n                backgroundColor={\n                  clickedCell.row === rowIndex ||\n                  clickedCell.column === columnIndex\n                    ? COLORS.onIncrement\n                    : COLORS.default\n                }\n              />\n            ))}\n          </div>\n        );\n      })}\n    </div>\n  );\n}\n","import React from \"react\";\nimport Grid from \"../Grid\";\n\nexport default function App() {\n  return <Grid numberOfRows={50} numberOfColumns={50} sequenceLength={5} />;\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./components/App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}